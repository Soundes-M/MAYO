-- Automatic generated by memory_generator.py 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tdp_BigBRAM_3 is
    generic (
        NB_COL          : integer := 4;             -- Specify number of columns (number of bytes)
        COL_WIDTH       : integer := 8;             -- Specify column width (byte width, typically 8 or 9)
        RAM_PERFORMANCE : string  := "LOW_LATENCY"       -- Select "HIGH_PERFORMANCE" or "LOW_LATENCY" 
    );

    port (
        addra  : in  std_logic_vector(31 downto 0);                 -- Port A Address bus, width determined from RAM_DEPTH
        addrb  : in  std_logic_vector(31 downto 0);                 -- Port B Address bus, width determined from RAM_DEPTH
        dina   : in  std_logic_vector(NB_COL*COL_WIDTH-1 downto 0); -- Port A RAM input data
        dinb   : in  std_logic_vector(NB_COL*COL_WIDTH-1 downto 0); -- Port B RAM input data
        clka   : in  std_logic;                                     -- Port A Clock
        clkb   : in  std_logic;                                     -- Port B Clock
        wea    : in  std_logic_vector(NB_COL-1 downto 0);           -- Port A Write enable
        web    : in  std_logic_vector(NB_COL-1 downto 0);           -- Port B Write enable
        ena    : in  std_logic;                                     -- Port A RAM Enable, for additional power savings, disable port when not in use
        enb    : in  std_logic;                                     -- Port B RAM Enable, for additional power savings, disable port when not in use
        rsta   : in  std_logic;                                     -- Port A Output reset (does not affect memory contents)
        rstb   : in  std_logic;                                     -- Port B Output reset (does not affect memory contents)
        regcea : in  std_logic;                                     -- Port A Output register enable
        regceb : in  std_logic;                                     -- Port B Output register enable
        douta  : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0); --  Port A RAM output data
        doutb  : out std_logic_vector(NB_COL*COL_WIDTH-1 downto 0)  --  Port B RAM output data
    );

end tdp_BigBRAM_3;

architecture rtl of tdp_BigBRAM_3 is

    ATTRIBUTE X_INTERFACE_INFO             : STRING;
    ATTRIBUTE X_INTERFACE_INFO of clka     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA CLK";
    ATTRIBUTE X_INTERFACE_INFO of dina     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA DIN";
    ATTRIBUTE X_INTERFACE_INFO of addra    : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA ADDR";
    ATTRIBUTE X_INTERFACE_INFO of ena      : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA EN";
    ATTRIBUTE X_INTERFACE_INFO of rsta     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA RST";
    ATTRIBUTE X_INTERFACE_INFO of wea      : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA WE";
    ATTRIBUTE X_INTERFACE_INFO of douta    : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTA DOUT";
    
    ATTRIBUTE X_INTERFACE_INFO of clkb     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB CLK";
    ATTRIBUTE X_INTERFACE_INFO of dinb     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB DIN";
    ATTRIBUTE X_INTERFACE_INFO of addrb    : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB ADDR";
    ATTRIBUTE X_INTERFACE_INFO of enb      : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB EN";
    ATTRIBUTE X_INTERFACE_INFO of rstb     : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB RST";
    ATTRIBUTE X_INTERFACE_INFO of web      : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB WE";
    ATTRIBUTE X_INTERFACE_INFO of doutb    : SIGNAL is "xilinx.com:interface:bram:1.0 BRAM_PORTB DOUT";

    constant C_NB_COL          : integer := NB_COL;
    constant C_COL_WIDTH       : integer := COL_WIDTH;
    constant C_RAM_DEPTH       : integer := 65536;
    constant C_RAM_PERFORMANCE : string  := RAM_PERFORMANCE;

    signal douta_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others => '0');
    signal doutb_reg : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) := (others => '0');

    type ram_type is array (C_RAM_DEPTH-1 downto 0) of std_logic_vector (C_NB_COL*C_COL_WIDTH-1 downto 0); -- 2D Array Declaration for RAM signal

    signal ram_data_a : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;
    signal ram_data_b : std_logic_vector(C_NB_COL*C_COL_WIDTH-1 downto 0) ;

    -- Following code defines RAM
    shared variable ram_name : ram_type := (others => (others => '0'));

begin

    process(clka)
    begin
        if(clka'event and clka = '1') then
            if(ena = '1') then
                ram_data_a <= ram_name(to_integer(unsigned(addra(18-1 downto 2)))); -- word align
                for i in 0 to C_NB_COL-1 loop
                    if(wea(i) = '1') then
                        ram_name(to_integer(unsigned(addra(18-1 downto 2))))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dina((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                    end if;
                end loop;
            end if;
        end if;
    end process;

    process(clkb)
    begin
        if(clkb'event and clkb = '1') then
            if(enb = '1') then
                ram_data_b <= ram_name(to_integer(unsigned(addrb(18-1 downto 2)))); -- word align
                for i in 0 to C_NB_COL-1 loop
                    if(web(i) = '1') then
                        ram_name(to_integer(unsigned(addrb(18-1 downto 2))))((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH) := dinb((i+1)*C_COL_WIDTH-1 downto i*C_COL_WIDTH);
                    end if;
                end loop;
            end if;
        end if;
    end process;

    --  Following code generates LOW_LATENCY (no output register)
    --  Following is a 1 clock cycle read latency at the cost of a longer clock-to-out timing

    no_output_register : if C_RAM_PERFORMANCE = "LOW_LATENCY" generate
        douta <= ram_data_a;
        doutb <= ram_data_b;
    end generate;

    output_register : if C_RAM_PERFORMANCE = "HIGH_PERFORMANCE" generate
        process(clka)
        begin
            if(clka'event and clka = '1') then
                if(rsta = '1') then
                    douta_reg <= (others => '0');
                elsif(regcea = '1') then
                    douta_reg <= ram_data_a;
                end if;
            end if;
        end process;
        douta <= douta_reg;

        process(clkb)
        begin
            if(clkb'event and clkb = '1') then
                if(rstb = '1') then
                    doutb_reg <= (others => '0');
                elsif(regceb = '1') then
                    doutb_reg <= ram_data_b;
                end if;
            end if;
        end process;
        doutb <= doutb_reg;

    end generate;

end rtl;
